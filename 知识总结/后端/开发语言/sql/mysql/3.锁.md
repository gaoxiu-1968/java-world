# 锁

> 锁的目的是为了保证数据的可靠性

innoDB的锁一共有八种

* 共享锁和排它锁
* 意图锁
* 记录锁
* 间隙锁
* Next-Key锁
* 插入意向锁
* AUTO-INC锁
* 空间索引的谓词锁

参考： https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html

## 共享锁和排它锁

> 标准的行级锁

共享锁允许持有锁的事务读取一行

排它锁允许持有锁的事物更新或删除行

详细介绍：

```
如果事务 T1 在行 r 上持有共享 (S) 锁，那么来自某个不同事务 T2 的对行 r 的锁的请求将按如下方式处理：
可以立即授予 T2 对 S 锁的请求。 结果，T1 和 T2 都持有 r 的 S 锁。
T2 对 X 锁的请求不能立即被授予。
如果事务 T1 在行 r 上持有排他 (X) 锁，则不能立即授予来自某个不同事务 T2 的对 r 上任一类型锁的请求。 相反，事务 T2 必须等待事务 T1 释放其对行 r 的锁。
```

## 意图锁

> InnoDB 支持多粒度锁定，允许行锁和表锁共存。 意图锁是表级锁

意图锁分为两种意图共享锁，意图排它锁。

意图共享锁 (IS) 表示事务打算在表中的各个行上设置共享锁。

意图排他锁 (IX) 表示事务打算对表中的各个行设置排他锁。

除了全表请求（例如，[`LOCK TABLES ... WRITE`](https://dev.mysql.com/doc/refman/5.7/en/lock-tables.html)）之外，意图锁不会阻止任何内容。意图锁的主要目的是表明有人正在锁定一行，或者打算锁定表中的一行。

![image-20210904174011144](img/image-20210904174011144.png)

如果请求事务与现有锁兼容，则向请求事务授予锁，但如果与现有锁冲突，则不会。事务一直等到冲突的现有锁被释放。如果锁请求与现有锁冲突，并且由于会导致[死锁](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock)而无法授予 ，则会发生错误。

## 记录锁

记录锁是对索引记录的锁。

例如， `SELECT c1 FROM t WHERE c1 = 10 FOR UPDATE;` 可以防止插入，更新或删除行，其中的值的任何其它交易`t.c1`是 `10`。

记录锁总是锁定索引记录，即使一个表没有定义索引。对于这种情况， `InnoDB`创建一个隐藏的聚集索引并使用该索引进行记录锁定。

## 间隙锁

间隙锁是对索引记录之间的间隙的锁，或者是对第一个索引记录之前或最后一个索引记录之后的间隙的锁。

例如，SELECT c1 FROM t WHERE c1 BETWEEN 10 and 20 FOR UPDATE;防止其他事务将 15 的值插入到列 t.c1 中，无论该列中是否已经存在任何此类值，因为该范围内所有现有值之间的间隙已被锁定。

间隙可能跨越单个索引值、多个索引值，甚至是空的。

## Next-Key锁

next-key 锁是索引记录上的记录锁和索引记录之前的间隙上的间隙锁的组合。

## 插入意向锁

插入意向锁是一种在行插入之前由 INSERT 操作设置的间隙锁。

此锁表示插入意图。

## AUTO-INC锁

AUTO-INC 锁是一种特殊的表级锁，由插入到具有 AUTO_INCREMENT（自增长） 列的表中的事务获取。 在最简单的情况下，如果一个事务正在向表中插入值，则任何其他事务都必须等待自己插入到该表中，以便第一个事务插入的行接收连续的主键值。

## 空间索引的谓词锁

为了支持具有 SPATIAL 索引的表的隔离级别，InnoDB 使用谓词锁。

SPATIAL 索引包含最小边界矩形 (MBR) 值，因此 InnoDB 通过在用于查询的 MBR 值上设置谓词锁来强制对索引进行一致读取。 其他事务无法插入或修改与查询条件匹配的行。

# 常用sql背后设置的锁

## 查询 

[`SELECT ... FROM`](https://dev.mysql.com/doc/refman/5.7/en/select.html)是一致读，读取数据库的快照并且不设置锁，除非事务隔离级别设置为 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable)。对于 [`SERIALIZABLE`](https://dev.mysql.com/doc/refman/5.7/en/innodb-transaction-isolation-levels.html#isolevel_serializable)级别，搜索在它遇到的索引记录上设置共享的 next-key 锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。

## 插入

[`INSERT`](https://dev.mysql.com/doc/refman/5.7/en/insert.html)在插入的行上设置排他锁。这个锁是索引记录锁，不是next-key锁（即没有间隙锁），并且不会阻止其他会话在插入行之前插入间隙。

## 更新

[`UPDATE ... WHERE ...`](https://dev.mysql.com/doc/refman/5.7/en/update.html)在搜索遇到的每条记录上设置一个独占的 next-key 锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。

## 删除

[`DELETE FROM ... WHERE ...`](https://dev.mysql.com/doc/refman/5.7/en/delete.html)在搜索遇到的每条记录上设置一个独占的 next-key 锁。但是，对于使用唯一索引锁定行以搜索唯一行的语句，只需要索引记录锁。

# 死锁

> 因竞争锁资源而导致的死锁。

## 死锁案例

客户端A显示开启一个事务 读取一行数据并在这行数据上加上共享锁

客户端B显示开启一个事务 删除A读取的那行数据

客户端A要删除这条语句。

这里产生死锁的原因是因为A客户端需要个死锁X锁来删除，但是 B客户端已经使用X锁锁定，但是需要等到A事务结束释放S锁。

## 死锁检测

innoDB默认开启死锁检测，`InnoDB`自动检测事务 [死锁](https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_deadlock)并回滚一个或多个事务以打破死锁。

`InnoDB`尝试选择要回滚的小事务，其中事务的大小由插入、更新或删除的行数决定。

## 死锁发生情况

默认的情况下不会发生死锁，因为innoDB是按最小事务运行的。

也就是默认是autoCommit，每条运行的语句都是一个事务！

死锁只会发生在自己写的长事务中！